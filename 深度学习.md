# 环境配置：

## 环境：

1. Python：最底层，是解释器／语言本身。  
2. Anaconda：一个发行版，把 Python＋一堆常用科学包＋conda 这个包/环境管理器一起打包给你。  
3. conda：Anaconda 自带的包与环境管理器，可以装 Python 也可以装 C/C++/R 等非 Python 库；Anaconda 里默认用 conda 命令。  
4. PyTorch、TorchVision：纯 Python 包（含 C++ 扩展），用 conda 或 pip 都能装；Anaconda 把它们做成预编译好的 conda 包，省得你自己编译。  
5. Jupyter：也是纯 Python 包，Anaconda 把它预装好并配好启动器；你可以在任何 Python 环境里装，但 Anaconda 直接让你开箱即用。  


Anaconda 是一个“全家桶”，里面自带 Python 解释器、conda 包管理器、Jupyter 等常用工具；PyTorch/TorchVision 是你后来用 conda（或 pip）装进去的深度学习库。

```cpp
一维
二维：矩阵
三维及以上：张量
numpy为矩阵
tensor
    
    
```

深度学习简要理解：

```cpp
f即是神经网络，x表示输入，y表示输出
f(x) = y
```

```，
字母加粗表示矩阵或者向量，不加粗表示一个数值
```

| 维度 | 名称           | 例子                               |
| ---- | -------------- | ---------------------------------- |
| 0D   | 标量（Scalar） | `5`                                |
| 1D   | 向量（Vector） | `[1, 2, 3]`                        |
| 2D   | 矩阵（Matrix） | `[[1, 2], [3, 4]]`                 |
| 3D+  | 张量（Tensor） | 一批图片、视频、语言模型中的词向量 |

简单说：**Tensor 就是 NumPy 中的 `ndarray` 的“升级版”或“智能版”**，特别是在深度学习框架中。

# panda库

当然可以！`pandas`（通常简写为 `pd`）是 Python 中最强大、最广泛使用的**数据分析和操作库**之一。它特别适合处理结构化数据（如表格、CSV 文件、Excel 表格等），在数据科学、机器学习、金融分析等领域几乎成为“标配”。

---

## 📦 一、pandas 简介

- 官网：[https://pandas.pydata.org](https://pandas.pydata.org)
- 主要数据结构：
  - `Series`：一维数组（带标签）
  - `DataFrame`：二维表格（类似 Excel 表格）

> ✅ 你可以把 `DataFrame` 想象成一个“带列名和行索引的 Excel 表格”。

---

## 🚀 二、基本导入与创建

```python
import pandas as pd
import numpy as np
```

### 1. 创建 Series（一维）

```python
s = pd.Series([1, 3, 5, np.nan, 6, 8])
print(s)
```
输出：
```
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
```

### 2. 创建 DataFrame（二维）

```python
df = pd.DataFrame({
    '姓名': ['张三', '李四', '王五'],
    '年龄': [25, 30, 35],
    '城市': ['北京', '上海', '广州'],
    '薪资': [8000, 12000, 15000]
})
print(df)
```

输出：
```
   姓名  年龄   城市    薪资
0  张三  25   北京   8000
1  李四  30   上海  12000
2  王五  35   广州  15000
```

---

## 📂 三、读取数据（常用方法）

pandas 支持多种文件格式：

| 方法                             | 说明            |
| -------------------------------- | --------------- |
| `pd.read_csv('file.csv')`        | 读取 CSV 文件   |
| `pd.read_excel('file.xlsx')`     | 读取 Excel 文件 |
| `pd.read_json('file.json')`      | 读取 JSON 文件  |
| `pd.read_sql(query, connection)` | 从数据库读取    |

### 示例：读取 CSV
```python
df = pd.read_csv('data.csv')
```

常用参数：
- `encoding='utf-8'`：指定编码（中文常用）
- `index_col=0`：设置第一列为行索引
- `usecols=['A', 'B']`：只读取某些列
- `nrows=100`：只读前 100 行（用于测试）

---

## 🔍 四、查看数据（探索性数据分析）

| 方法            | 功能                                           |
| --------------- | ---------------------------------------------- |
| `df.head()`     | 显示前 5 行                                    |
| `df.tail()`     | 显示后 5 行                                    |
| `df.info()`     | 查看数据类型、非空值数量                       |
| `df.describe()` | 数值列的统计摘要（均值、标准差、最小最大值等） |
| `df.shape`      | 返回 (行数, 列数)                              |
| `df.columns`    | 查看所有列名                                   |
| `df.dtypes`     | 查看每列的数据类型                             |

示例：
```python
print(df.info())
print(df.describe())
```

---

## 🧹 五、数据清洗与预处理

### 1. 处理缺失值（NaN）

```python
df.isnull()           # 返回布尔值，判断是否为空
df.isnull().sum()     # 每列缺失值数量
df.dropna()           # 删除有缺失值的行
df.fillna(0)          # 用 0 填充缺失值
df.fillna(method='ffill')  # 向前填充
df.fillna(method='bfill')  # 向后填充
```

### 2. 处理重复值

```python
df.duplicated()       # 判断是否重复行
df.drop_duplicates()  # 删除重复行
```

### 3. 修改数据类型

```python
df['年龄'] = df['年龄'].astype(int)
df['日期'] = pd.to_datetime(df['日期'])  # 转为日期类型
```

---

## 🔎 六、数据选择与索引

### 1. 选择列

```python
df['姓名']                    # 单列 → Series
df[['姓名', '年龄']]           # 多列 → DataFrame
```

### 2. 选择行（基于标签或位置）

| 方法                         | 说明                   |
| ---------------------------- | ---------------------- |
| `df.loc[0]`                  | 按标签选择（行索引）   |
| `df.loc[0:2, '姓名':'城市']` | 标签切片（包含右端）   |
| `df.iloc[0]`                 | 按位置选择（第0行）    |
| `df.iloc[0:2, 0:2]`          | 位置切片（不包含右端） |

示例：
```python
row = df.loc[1]           # 第1行（标签为1）
subset = df.iloc[0:2, 1:3] # 前两行，第2~3列
```

### 3. 条件筛选

```python
df[df['年龄'] > 30]
df[(df['城市'] == '北京') & (df['薪资'] > 9000)]
```

> ⚠️ 注意：多个条件用 `&`（与）、`|`（或），并且每个条件加括号！

---

## 🧮 七、数据计算与变换

### 1. 数学运算

```python
df['薪资'].mean()       # 平均值
df['薪资'].max(), df['薪资'].min()
df['薪资'].std()        # 标准差
df['薪资'] * 1.1        # 涨薪10%
```

### 2. 添加新列

```python
df['税后薪资'] = df['薪资'] * 0.8
df['是否年轻'] = df['年龄'] < 30
```

### 3. 字符串操作（`.str`）

```python
df['姓名'].str.upper()          # 转大写
df['城市'].str.contains('京')    # 是否包含“京”
```

### 4. 日期操作（`.dt`）

```python
df['日期'].dt.year      # 提取年份
df['日期'].dt.month
df['日期'].dt.dayofweek
```

---

## 📊 八、分组与聚合（`groupby`）

这是 pandas 最强大的功能之一！

```python
# 按城市分组，计算平均薪资
df.groupby('城市')['薪资'].mean()

# 多列聚合
df.groupby('城市').agg({
    '薪资': 'mean',
    '年龄': 'max'
})
```

输出示例：
```
城市
北京     8000
上海    12000
广州    15000
```

---

## 🔗 九、合并与连接数据

| 方法                            | 说明                  |
| ------------------------------- | --------------------- |
| `pd.concat([df1, df2])`         | 上下拼接（纵向）      |
| `pd.concat([df1, df2], axis=1)` | 左右拼接（横向）      |
| `pd.merge(df1, df2, on='id')`   | 类似 SQL 的 JOIN 操作 |

示例：
```python
merged = pd.merge(df1, df2, on='员工ID', how='left')
```

---

## 💾 十、保存数据

```python
df.to_csv('output.csv', index=False)        # 不保存索引
df.to_excel('output.xlsx', sheet_name='Sheet1')
df.to_json('output.json')
```

> ✅ `index=False` 很重要，否则会多出一列无意义的索引。

---

## 🎯 十一、实际应用场景举例

假设你有一个 `students.csv` 文件：

```csv
name,age,city,score
Alice,20,Beijing,85
Bob,21,Shanghai,90
Charlie,19,Beijing,78
David,22,Shanghai,95
```

你想分析：
- 北京学生的平均成绩
- 谁分数最高？

代码如下：

```python
import pandas as pd

# 读取数据
df = pd.read_csv('students.csv')

# 查看基本信息
print(df.info())

# 北京学生的平均成绩
beijing_avg = df[df['city'] == 'Beijing']['score'].mean()
print(f"北京学生平均成绩: {beijing_avg}")

# 分数最高的学生
top_student = df.loc[df['score'].idxmax(), 'name']
print(f"最高分学生: {top_student}")
```

---

## ✅ 总结：pandas 的核心优势

| 特性       | 说明                                            |
| ---------- | ----------------------------------------------- |
| **易用性** | 接口直观，类似 Excel 操作                       |
| **灵活性** | 支持各种数据类型和操作                          |
| **高效性** | 基于 NumPy，速度快                              |
| **生态好** | 与 Matplotlib、Seaborn、Scikit-learn 等无缝集成 |

---

# Dataset

当然可以！在深度学习和机器学习中，`Dataset` 是一个非常核心的概念。你提到的 `Dataset`，通常是指 **PyTorch 中的 `torch.utils.data.Dataset`** 类。它是构建数据加载流水线（data pipeline）的基础组件。

---

## 📚 一、什么是 `Dataset`？

`Dataset` 是 PyTorch 提供的一个**抽象类**，用于表示数据集。你需要继承它，并实现一些基本方法，来告诉模型：“我的数据长什么样？怎么读取一条样本？”

> ✅ 简单说：`Dataset` 就是一个可以“按索引取数据”的对象，比如 `dataset[0]` 返回第一条数据。

---

## 🔗 二、为什么要用 Dataset？

在训练神经网络时，我们不能一次性把所有数据都加载进内存，也不能直接把原始文件喂给模型。

我们需要：
1. **统一格式**：把图像、文本、CSV 等转成张量（Tensor）
2. **按需读取**：每次只加载一个或一批数据（节省内存）
3. **支持打乱、批处理**：配合 `DataLoader` 使用

而 `Dataset` 就是这个过程的第一步 —— 定义“如何获取单个样本”。

---

## 🧱 三、Dataset 的核心方法

你必须继承 `Dataset` 并实现两个方法：

### 1. `__len__(self)`初始化，指定文件路径
返回数据集的总样本数。

```python
def __len__(self):
    return len(self.data)
```

### 2. `__getitem__(self, idx)取数据`
根据索引 `idx` 返回一条数据（通常是 `(输入, 标签)` 的元组）。

```python
def __getitem__(self, idx):
    sample = self.data[idx]
    label = self.labels[idx]
    return sample, label
```

---

## 🛠️ 四、自定义 Dataset 示例

下面我们通过几个常见任务来演示如何写 `Dataset`。

---

### ✅ 示例 1：从 NumPy 数组创建 Dataset

```python
import torch
from torch.utils.data import Dataset

class MyDataset(Dataset):
    def __init__(self, data, labels):
        self.data = data
        self.labels = labels

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx	):
        # 返回数据和标签（自动转为 Tensor）
        return torch.tensor(self.data[idx], dtype=torch.float32), \
               torch.tensor(self.labels[idx], dtype=torch.long)

# 使用示例
import numpy as np
X = np.random.rand(100, 10)  # 100 个样本，每个 10 维
y = np.random.randint(0, 2, 100)

dataset = MyDataset(X, y)
print(len(dataset))           # 100
print(dataset[0])             # (tensor([...]), tensor(0))
```

---

### ✅ 示例 2：读取图像文件（如分类任务）

假设你有一个图像分类任务，结构如下：

```
data/
├── cat1.jpg
├── dog1.jpg
└── labels.csv
```

`labels.csv` 内容：
```
filename,label
cat1.jpg,0
dog1.jpg,1
```

代码实现：

```python
import pandas as pd
from PIL import Image
import os

class ImageDataset(Dataset):
    def __init__(self, csv_file, root_dir, transform=None):
        self.annotations = pd.read_csv(csv_file)
        self.root_dir = root_dir
        self.transform = transform

    def __len__(self):
        return len(self.annotations)

    def __getitem__(self, idx):
        img_path = os.path.join(self.root_dir, self.annotations.iloc[idx, 0])
        image = Image.open(img_path).convert("RGB")  # 读取图像
        label = int(self.annotations.iloc[idx, 1])

        if self.transform:
            image = self.transform(image)  # 如 ToTensor(), Resize 等

        return image, label

# 使用示例
transform = transforms.Compose([
    transforms.Resize((64, 64)),
    transforms.ToTensor()
])

dataset = ImageDataset(csv_file='labels.csv', root_dir='data', transform=transform)
image, label = dataset[0]
```

---

### ✅ 示例 3：文本分类 Dataset

```python
from torch.nn.utils.rnn import pad_sequence

class TextDataset(Dataset):
    def __init__(self, texts, labels, tokenizer):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = self.texts[idx]
        label = self.labels[idx]
        # 简单分词（实际可用 BERT tokenizer）
        tokens = text.split()
        return tokens, label

# 注意：文本长度不同，需要配合 collate_fn 使用（见 DataLoader 部分）
```

---

## ⚙️ 五、Dataset 和 DataLoader 的关系

| 组件         | 作用                                           |
| ------------ | ---------------------------------------------- |
| `Dataset`    | 定义“如何读取单个样本”                         |
| `DataLoader` | 包装 Dataset，提供批量加载、打乱、多进程等功能 |

```python
from torch.utils.data import DataLoader

dataset = MyDataset(data, labels)
dataloader = DataLoader(
    dataset,
    batch_size=32,
    shuffle=True,
    num_workers=4
)

# 训练循环
for batch in dataloader:
    inputs, targets = batch
    outputs = model(inputs)
    loss = criterion(outputs, targets)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
```

> 🔁 `DataLoader` 会自动调用 `dataset[i]` 来构建每个 batch。

---

## 🧩 六、Dataset 的高级技巧

### 1. 支持 `transform` 预处理

很多 Dataset 设计支持传入 `transform` 函数，用于数据增强或标准化：

```python
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
])

dataset = ImageDataset(csv_file, root_dir, transform=transform)
```

这样可以在读取图像后立即进行预处理。

---

### 2. 使用 `__add__` 合并 Dataset

PyTorch 支持用 `+` 合并两个 Dataset：

```python
dataset1 = MyDataset(data1, labels1)
dataset2 = MyDataset(data2, labels2)
combined_dataset = dataset1 + dataset2
```

内部会创建一个 `ConcatDataset`。

---

### 3. 子集划分（训练/验证集）

使用 `torch.utils.data.random_split`：

```python
train_size = int(0.8 * len(dataset))
val_size = len(dataset) - train_size
train_dataset, val_dataset = random_split(dataset, [train_size, val_size])
```

---

## ✅ 总结：Dataset 的作用

| 功能                   | 说明                         |
| ---------------------- | ---------------------------- |
| **封装数据访问逻辑**   | `dataset[i]` 返回第 i 条数据 |
| **统一输入格式**       | 把原始数据转为 Tensor        |
| **支持预处理**         | 如图像变换、文本编码         |
| **与 DataLoader 配合** | 构建高效的训练数据流         |

---

# Tensor

当然可以！`Tensor`（张量）是 **PyTorch 的核心数据结构**，也是现代深度学习的“基石”。你可以把它理解为 **多维数组（N-dimensional array）**，但它比 NumPy 的 `ndarray` 更强大，因为它支持：

- 🚀 **GPU 加速计算**
- 🔁 **自动求导（Autograd）**
- 🧠 **神经网络训练的基础载体**

---

## 📦 一、什么是 Tensor？

> **Tensor 就是一个可以存储数值的多维容器**，比如：
- 0维：标量（scalar） → 比如 `5`
- 1维：向量（vector） → 比如 `[1, 2, 3]`
- 2维：矩阵（matrix） → 比如 `[[1, 2], [3, 4]]`
- 3维及以上：高维张量 → 常用于图像、视频、文本等

在 PyTorch 中，所有模型的输入、输出、权重、梯度都是 `Tensor`。

---

## 🔧 二、创建 Tensor 的常见方式

### 1. 从 Python 列表或 NumPy 数组创建

```python
import torch
import numpy as np

# 从列表创建
t1 = torch.tensor([1, 2, 3])
print(t1)  # tensor([1, 2, 3])

# 从 NumPy 数组创建
arr = np.array([4, 5, 6])
t2 = torch.from_numpy(arr)
print(t2)  # tensor([4, 5, 6])

# 转回 NumPy
np_arr = t2.numpy()
```

> ✅ 注意：`torch.tensor()` 会**复制数据**，`torch.from_numpy()` 是**共享内存**（改一个，另一个也变）

---

### 2. 创建特定值的 Tensor

| 方法                      | 说明                                   |
| ------------------------- | -------------------------------------- |
| `torch.zeros(2, 3)`       | 全0张量，形状 (2,3)                    |
| `torch.ones(3, 3)`        | 全1张量                                |
| `torch.eye(3)`            | 单位矩阵                               |
| `torch.randn(2, 4)`       | 标准正态分布随机数（常用于初始化权重） |
| `torch.arange(0, 10, 2)`  | 等差序列：`[0, 2, 4, 6, 8]`            |
| `torch.linspace(0, 1, 5)` | 0到1均匀分布的5个数                    |

示例：
```python
x = torch.randn(3, 4)  # 3x4 的随机张量
print(x.shape)         # torch.Size([3, 4])
```

---

## 🧮 三、Tensor 的基本属性

| 属性                    | 说明                                        |
| ----------------------- | ------------------------------------------- |
| `t.shape` 或 `t.size()` | 形状，如 `(3, 4)`                           |
| `t.dtype`               | 数据类型，如 `torch.float32`, `torch.int64` |
| `t.device`              | 存储设备，如 `cpu` 或 `cuda:0`              |
| `t.requires_grad`       | 是否记录梯度（用于反向传播）                |
| `t.grad`                | 梯度值（反向传播后自动填充）                |

示例：
```python
x = torch.tensor([1.0, 2.0], requires_grad=True)
print(x.dtype)        # torch.float32
print(x.device)       # cpu
print(x.requires_grad) # True
```

---

## 🔄 四、Tensor 的基本操作

### 1. 数学运算（与 NumPy 风格一致）

```python
a = torch.tensor([1, 2])
b = torch.tensor([3, 4])

print(a + b)      # 加法 → tensor([4, 6])
print(a * b)      # 逐元素乘法 → tensor([3, 8])
print(torch.dot(a, b))  # 点积 → 11
print(torch.matmul(a, b))  # 矩阵乘法（这里也是点积）
```

支持几乎所有数学函数：
- `torch.sin()`, `torch.exp()`, `torch.log()`
- `torch.sum()`, `torch.mean()`, `torch.max()`

---

### 2. 改变形状（Reshape）

```python
x = torch.arange(6)  # [0, 1, 2, 3, 4, 5]
x = x.reshape(2, 3)  # 变成 2x3 矩阵
# 或者
x = x.view(2, 3)     # view 与 reshape 类似（但 view 要求连续内存）
```

> ✅ `reshape` 更安全，推荐使用。

---

### 3. 索引与切片（和 Python/NumPy 一样）

```python
x = torch.tensor([[1, 2, 3],
                  [4, 5, 6]])

print(x[0])        # 第一行 → [1, 2, 3]
print(x[:, 1])     # 第一列 → [2, 5]
print(x[0, :2])    # 第一行前两个 → [1, 2]
```

---

### 4. 设备迁移（CPU ↔ GPU）

```python
if torch.cuda.is_available():
    device = torch.device("cuda")
else:
    device = torch.device("cpu")

x = x.to(device)  # 移动到 GPU（如果可用）
# 或者直接创建在 GPU 上
x = torch.randn(3, 3).to("cuda")
```

> ⚡ GPU 上的 Tensor 可以极大加速训练！

---

## 🔁 五、自动求导（Autograd）—— Tensor 的灵魂功能！

这是 PyTorch 最强大的特性之一：**自动计算梯度**。

```python
x = torch.tensor(2.0, requires_grad=True)
y = x ** 2 + 3 * x + 1  # y = x² + 3x + 1

y.backward()  # 反向传播，计算 dy/dx
print(x.grad)  # dy/dx = 2x + 3 = 2*2 + 3 = 7 → tensor(7.)
```

> ✅ 在神经网络中，`loss.backward()` 就是靠这个更新权重！

---

## 🧩 六、Tensor 与神经网络的关系

在深度学习中：
- **输入数据**：图片 → `torch.Size([3, 224, 224])`（3通道图像）
- **模型权重**：每一层的参数都是 `Tensor`，且 `requires_grad=True`
- **前向传播**：输入 Tensor 经过多层运算得到输出
- **损失计算**：输出与真实标签比较，得到 loss（标量 Tensor）
- **反向传播**：`loss.backward()` 自动计算所有参数的梯度
- **参数更新**：优化器（如 SGD）用梯度更新权重

---

## 📊 七、Tensor 与 NumPy 的对比

| 特性               | Tensor (PyTorch)   | NumPy `ndarray` |
| ------------------ | ------------------ | --------------- |
| GPU 支持           | ✅ 是               | ❌ 否            |
| 自动求导           | ✅ 是               | ❌ 否            |
| 数据类型更丰富     | ✅ 如 float16, int8 | ❌ 有限          |
| 与深度学习框架集成 | ✅ 原生支持         | ❌ 需转换        |
| 语法风格           | 高度兼容 NumPy     | 原生            |

> ✅ 两者可以无缝转换：
```python
tensor = torch.from_numpy(np_array)
np_array = tensor.numpy()
```

---

## 🎯 八、常见应用场景

| 场景        | Tensor 示例                               |
| ----------- | ----------------------------------------- |
| 图像分类    | `shape: [3, 224, 224]`（RGB 图像）        |
| 批量训练    | `shape: [32, 3, 224, 224]`（32张图）      |
| NLP（文本） | `shape: [batch, seq_len]`（词 ID 序列）   |
| 回归任务    | 输出 `shape: [batch, 1]`                  |
| 多分类      | 标签 `long` 类型，用于 `CrossEntropyLoss` |

---

## ✅ 总结：Tensor 的核心地位

| 特性         | 说明                            |
| ------------ | ------------------------------- |
| **数据载体** | 所有输入、输出、参数都是 Tensor |
| **计算基础** | 支持高效数学运算                |
| **GPU 加速** | 可运行在 GPU 上，极大提升速度   |
| **自动求导** | 支持 `backward()`，实现梯度下降 |
| **灵活易用** | 接口类似 NumPy，学习成本低      |

---

# WithOpen

使用 `with open` 的好处在于，当代码块执行完毕或者发生异常时，文件会自动被关闭，无需显式调用 `file.close()` 方法。这有助于避免由于忘记关闭文件导致的资源泄露问题。例如：

```python
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# 在这里，不需要调用 file.close()，因为 with 语句已经确保文件被关闭。
```

# numpy切片

当然可以！我们来系统、详细地讲解 **NumPy 中的 `[]` 切片（Slicing）操作**。这是数据处理中最核心、最常用的技能之一，掌握它就掌握了 NumPy 的“钥匙”。

---

## 📚 一、什么是切片（Slicing）？

在 NumPy 中，**切片** 是指从数组中提取一部分元素的操作，语法类似于 Python 列表的切片：

```python
array[start:end:step]
```

但 NumPy 支持 **多维数组** 的切片，可以用逗号 `,` 分隔不同维度的操作。

---

## 🔧 二、基本语法：`[start:end:step]`

| 部分    | 说明                   |
| ------- | ---------------------- |
| `start` | 起始索引（包含）       |
| `end`   | 结束索引（**不包含**） |
| `step`  | 步长（可选，默认为1）  |

> ✅ 索引从 `0` 开始，支持负数（如 `-1` 表示最后一个）

### 示例（一维数组）：
```python
import numpy as np
arr = np.array([10, 20, 30, 40, 50])

print(arr[1:4])    # [20, 30, 40] → 从索引1到3（不含4）
print(arr[:3])     # [10, 20, 30] → 从开头到索引2
print(arr[2:])     # [30, 40, 50] → 从索引2到末尾
print(arr[::2])    # [10, 30, 50] → 每隔一个取一个
print(arr[::-1])   # [50, 40, 30, 20, 10] → 反转数组
```

---

## 🧱 三、二维数组切片：`[行, 列]`

对于二维数组（矩阵），切片语法是：

```python
array[行切片, 列切片]
```

### 示例数组：
```python
x1 = np.array([[1,  2,  3],
               [4,  5,  6],
               [7,  8,  9],
               [11, 12, 13]])
```
形状：`(4, 3)` → 4行3列

---

### ✅ 1. 只切行

```python
x1[1:]      # 从第1行开始到末尾
# 输出：
# [[ 4  5  6]
#  [ 7  8  9]
#  [11 12 13]]
```

```python
x1[1:3]     # 第1行和第2行（不含第3行）
# 输出：
# [[4 5 6]
#  [7 8 9]]
```

---

### ✅ 2. 只切列

```python
x1[:, 1]    # 所有行，第1列（索引为1）→ 降维为一维
# 输出：[ 2  5  8 12]
```

```python
x1[:, 1:2]  # 所有行，第1列 → 保持二维（注意是切片）
# 输出：
# [[ 2]
#  [ 5]
#  [ 8]
#  [12]]
```

> 🔁 `:` 表示“所有”，类似通配符

---

### ✅ 3. 同时切行和列

```python
x1[1:, :1]  # 第1行及以后，第0列（即第一列）
# 输出：
# [[ 4]
#  [ 7]
#  [11]]
```

分解：
- `1:` → 行：索引1,2,3
- `:1` → 列：索引0（因为左闭右开）

---

### ✅ 4. 更多组合示例

| 表达式         | 含义               | 结果              |
| -------------- | ------------------ | ----------------- |
| `x1[0, :]`     | 第0行，所有列      | `[1, 2, 3]`       |
| `x1[:, 0]`     | 所有行，第0列      | `[1, 4, 7, 11]`   |
| `x1[1:3, 1:3]` | 第1~2行，第1~2列   | `[[5,6],[8,9]]`   |
| `x1[::2, ::2]` | 隔行取，隔列取     | `[[1,3],[7,9]]`   |
| `x1[-2:, -2:]` | 最后两行，最后两列 | `[[8,9],[12,13]]` |

---

## 🌀 四、高级技巧

### 1. 负索引（Negative Indexing）

```python
x1[-1]      # 最后一行 → [11,12,13]
x1[:, -1]   # 最后一列 → [3,6,9,13]
x1[-2:, -2:] # 右下角 2x2 子矩阵
```

---

### 2. 布尔索引（Boolean Indexing）

用布尔条件筛选元素：

```python
arr = np.array([1, 2, 3, 4, 5])
mask = arr > 3
print(arr[mask])  # [4, 5]
```

二维示例：
```python
x1[x1 > 5]  # 所有大于5的元素 → [6,7,8,9,11,12,13]
```

---

### 3. 花式索引（Fancy Indexing）——用列表取特定行/列

```python
x1[[0, 2], :]  # 取第0行和第2行
# 输出：
# [[1 2 3]
#  [7 8 9]]
```

```python
x1[:, [0, 2]]  # 取第0列和第2列
# 输出：
# [[ 1  3]
#  [ 4  6]
#  [ 7  9]
#  [11 13]]
```

# python中的存储

当然可以！Python 中有多种**内置的数据结构（存储方式）**，用于组织和管理数据。以下是 Python 中最常见、最常用的几种数据结构，以及它们的特点、使用场景和示例。

---

## 🧱 一、Python 常见数据结构概览

| 数据结构                          | 可变？ | 有序？            | 允许重复？   | 主要用途       |
| --------------------------------- | ------ | ----------------- | ------------ | -------------- |
| **列表（List）**                  | ✅ 是   | ✅ 是              | ✅ 是         | 存储有序序列   |
| **元组（Tuple）**                 | ❌ 否   | ✅ 是              | ✅ 是         | 存储不可变序列 |
| **字典（Dict）**                  | ✅ 是   | ❌ 否（3.7+ 有序） | ❌ 键不能重复 | 键值对映射     |
| **集合（Set）**                   | ✅ 是   | ❌ 无序            | ❌ 否         | 去重、集合运算 |
| **字符串（String）**              | ❌ 否   | ✅ 是              | ✅ 是         | 文本数据       |
| **数组（Array / NumPy ndarray）** | ✅ 是   | ✅ 是              | ✅ 是         | 数值计算       |

下面我们逐一详细介绍：

---

## 1. 📋 列表（List）—— `[ ]`

### 特点：
- 用方括号 `[]` 定义
- **可变（mutable）**：可以增删改元素
- **有序（ordered）**：元素有固定顺序
- **允许重复元素**
- 

## ✅ 1. `list` 本质是一维的

Python 的 `list` 是一个**有序的可变序列**，它按**单一索引**存储元素：

python深色版本

```
lst = [1, 2, 3, 4]
print(lst[0])  # 1
print(lst[1])  # 2
```

👉 它只有一个维度：**索引从 0 到 n-1**

------

## 🔁 2. 但 list 可以嵌套 → 实现“多维”

虽然 `list` 本身是一维的，但它的元素可以是另一个 `list`，从而模拟多维数组。

### 📌 二维列表（类似矩阵）

python深色版本

```
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[1][2])  # 6 → 第1行，第2列
```

- 外层 `list` 有 3 个元素，每个元素是一个 `list`
- 通过 `matrix[i][j]` 访问，看起来像二维数组

### 📌 三维列表

python深色版本

```
cube = [
    [[1, 2], [3, 4]],
    [[5, 6], [7, 8]]
]

print(cube[0][1][0])  # 3
```

- 第一维：块
- 第二维：行
- 第三维：列

### 示例：

```python
fruits = ['apple', 'banana', 'orange']
fruits.append('grape')        # 添加
fruits[0] = 'pear'            # 修改
print(fruits[1])              # 访问：'banana'
```

### 常用操作：
- `append()`, `extend()`, `insert()`
- `remove()`, `pop()`, `del`
- 切片：`lst[1:3]`

### 适用场景：
- 存储一组有序的数据（如成绩、名字、时间序列）

---

## 2. 📦 元组（Tuple）—— `( )`

### 特点：
- 用圆括号 `()` 定义
- **不可变（immutable）**：创建后不能修改
- **有序**
- **允许重复**

### 示例：
```python
point = (3, 5)
person = ('Alice', 25, 'Engineer')
print(person[1])  # 25
```

### 为什么用元组？
- 保证数据不被意外修改
- 可作为字典的键（`list` 不行）
- 函数返回多个值时默认用元组

```python
def get_name_age():
    return "Bob", 30  # 返回元组
```

---

## 3. 📖 字典（Dictionary）—— `{ }`（键值对）

### 特点：
- 用花括号 `{}` 定义
- **可变**
- **3.7+ 保证插入顺序**
- **键（key）唯一且不可变**，值（value）任意

### 示例：
```python
student = {
    "name": "Alice",
    "age": 20,
    "grades": [85, 90, 78]
}

print(student["name"])           # 访问
student["age"] = 21              # 修改
student["city"] = "Beijing"      # 添加
```

### 常用方法：
- `keys()`, `values()`, `items()`
- `get()`, `pop()`, `update()`

### 适用场景：
- 配置信息、JSON 数据、对象属性、缓存

---

## 4. 🔢 集合（Set）—— `{ }`（无键值）

### 特点：
- 用花括号 `{}` 或 `set()` 定义
- **可变**（`frozenset` 是不可变版本）
- **无序**
- **不允许重复**（自动去重）

### 示例：
```python
numbers = {1, 2, 3, 2, 1}
print(numbers)  # {1, 2, 3} → 自动去重

# 集合运算
a = {1, 2, 3}
b = {3, 4, 5}
print(a | b)  # 并集 {1,2,3,4,5}
print(a & b)  # 交集 {3}
print(a - b)  # 差集 {1,2}
```

### 适用场景：
- 去重：`list(set(lst))`
- 成员检测（比 list 快）
- 数学集合运算

---

## 5. 🔤 字符串（String）—— `' '` 或 `" "`

### 特点：
- 文本数据
- **不可变**
- **有序**
- 支持索引和切片

### 示例：
```python
text = "Hello"
print(text[0])     # 'H'
print(text[1:4])   # 'ell'
# text[0] = 'X'   # ❌ 报错！字符串不可变
```

### 常用方法：
- `split()`, `join()`, `replace()`
- `upper()`, `lower()`, `strip()`
- `find()`, `startswith()`

---

## 6. 🧮 数组（NumPy Array）—— `np.array()`

> 需要安装：`pip install numpy`

### 特点：
- 高效的**多维数值数组**
- 支持向量化运算
- 用于科学计算、机器学习

### 示例：
```python
import numpy as np

arr = np.array([1, 2, 3])
matrix = np.array([[1,2], [3,4]])

print(arr * 2)        # [2 4 6] → 向量化
print(matrix.shape)   # (2, 2)
```

### 优势：
- 比 list 更快（C 实现）
- 支持广播、矩阵运算
- 与 PyTorch/TensorFlow 兼容

---

## 7. 📄 其他常见结构（扩展）

| 结构                  | 说明                                                    |
| --------------------- | ------------------------------------------------------- |
| **deque**（双端队列） | `from collections import deque`，支持两端高效添加/删除  |
| **defaultdict**       | 字典的子类，访问不存在的键时不会报错                    |
| **Counter**           | 统计元素频次：`Counter(['a','b','a']) → {'a':2, 'b':1}` |
| **namedtuple**        | 带字段名的元组：`Point = namedtuple('Point', 'x y')`    |
| **dataclass**         | Python 3.7+，简化类定义（类似自动构造的结构体）         |

---

## ✅ 如何选择？

| 需求                     | 推荐结构      |
| ------------------------ | ------------- |
| 存一组有序数据，可能修改 | `list`        |
| 存一组固定不变的数据     | `tuple`       |
| 存键值对（如配置、属性） | `dict`        |
| 去重或集合运算           | `set`         |
| 处理大量数字/矩阵        | `numpy.array` |
| 高效插入/删除首尾        | `deque`       |
| 统计词频                 | `Counter`     |

---

## 💡 小贴士

- 所有结构都可以**嵌套使用**：
  ```python
  data = [
      {"name": "Alice", "scores": [85, 90]},
      {"name": "Bob",   "scores": [78, 88]}
  ]
  ```
  
- 使用 `type(obj)` 查看类型

- 使用 `isinstance(obj, list)` 判断类型



# enumerate和range

`enumerate()` 和 `range()` 是 Python 中两个常用但**用途完全不同**的函数。虽然它们都常用于 `for` 循环中，但解决的问题不同。

---

## 🔍 一、`range()`：生成数字序列

### ✅ 作用：
生成一个**整数序列**，通常用于控制循环次数。

### 📌 语法：
```python
range(start, stop, step)
```

### 🌰 示例：
```python
for i in range(5):
    print(i)
# 输出：0, 1, 2, 3, 4
```

```python
for i in range(2, 5):
    print(i)
# 输出：2, 3, 4
```

---

## 🔍 二、`enumerate()`：为可迭代对象添加索引

### ✅ 作用：
遍历一个**可迭代对象**（如列表、字符串、元组等）的同时，**自动提供索引和值**。

### 📌 语法：
```python
enumerate(iterable, start=0)
```

### 🌰 示例：
```python
fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(index, fruit)
```

输出：
```
0 apple
1 banana
2 cherry
```

你也可以指定起始索引：
```python
for index, fruit in enumerate(fruits, start=1):
    print(index, fruit)
```

输出：
```
1 apple
2 banana
3 cherry
```

---

## ✅ 三、核心区别对比

| 特性             | `range()`                 | `enumerate()`                     |
| ---------------- | ------------------------- | --------------------------------- |
| **用途**         | 生成数字序列              | 为可迭代对象添加索引              |
| **输入**         | 数字（start, stop, step） | 可迭代对象（list, str, tuple 等） |
| **输出**         | 数字序列                  | (索引, 值) 的元组                 |
| **是否依赖数据** | 否，只生成数字            | 是，依赖传入的可迭代对象          |
| **典型用法**     | 控制循环次数              | 遍历列表/字符串并获取索引         |

---

## 🆚 四、对比示例

### 场景：遍历列表 `['a', 'b', 'c']`，同时获取索引和值

### ❌ 使用 `range()`（需要手动索引）
```python
lst = ['a', 'b', 'c']
for i in range(len(lst)):
    print(i, lst[i])
```

### ✅ 使用 `enumerate()`（更简洁、更 Pythonic）
```python
lst = ['a', 'b', 'c']
for i, value in enumerate(lst):
    print(i, value)
```

> ✅ `enumerate` 更清晰、更安全（避免索引越界）、更高效。

---

## ✅ 五、什么时候用哪个？

| 需求                  | 使用                       |
| --------------------- | -------------------------- |
| 想循环 10 次          | ✅ `range(10)`              |
| 遍历列表并需要索引    | ✅ `enumerate(list)`        |
| 遍历字符串并知道位置  | ✅ `enumerate("hello")`     |
| 生成 0 到 9 的数字    | ✅ `range(10)`              |
| 遍历字典的 key 和索引 | ✅ `enumerate(dict.keys())` |

---

## ✅ 六、常见误区

### ❌ 错误：用 `range` 遍历列表（不推荐）
```python
for i in range(len(my_list)):
    print(my_list[i])  # 多余，可读性差
```

### ✅ 正确：直接遍历或使用 `enumerate`
```python
# 只需要值
for item in my_list:
    print(item)

# 需要索引和值
for i, item in enumerate(my_list):
    print(i, item)
```

---

## ✅ 总结

| 函数                  | 用途                      | 推荐场景                     |
| --------------------- | ------------------------- | ---------------------------- |
| `range(n)`            | 生成 0 到 n-1 的数字      | 控制循环次数                 |
| `enumerate(iterable)` | 遍历对象并返回 (索引, 值) | 遍历列表、字符串等并需要索引 |

> 💡 **记住一句话**：
> - 你要的是**数字序列**？→ 用 `range`
> - 你要的是**带索引的数据**？→ 用 `enumerate`

✅ `enumerate` 更适合数据处理，`range` 更适合计数循环。

---

